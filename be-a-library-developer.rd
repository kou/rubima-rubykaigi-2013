= ライブラリー開発者になろう

この記事は((<RubyKaigi 2013|URL:http://rubykaigi.org/2013>))の3日目の午後にあった((<Be a library developer!|URL:http://rubykaigi.org/2013/talk/S94>))という発表に関する記事です。発表のまとめと、発表に対するコメントにコメントします。

発表資料は以下にあります。このまとめは資料を見なくてもわかるようにしますが、資料に興味がでた人は以下のうち好きなサイトで見てください。どれも同じPDFをアップロードしています。

  * ((<SlideShare|URL:slideshare.net/kou/rubykaigi-2013>))
  * ((<Speaker Deck|URL:http://speakerdeck.com/u/kou/p/be-a-library-developer>))
  * ((<Rabbit Slide Show|URL:http://slide.rabbit-shocker.org/authors/kou/rubykaigi-2013/>))

発表資料のソースはGitHubにあります。

  * ((<'kou/rabbit-slide-kou-rubykaigi-2013'|URL:https://github.com/kou/rabbit-slide-kou-rubykaigi-2013>))

当日の動画は以下にあります。どちらも同じ動画です。

  * ((<Ustream|URL:http://www.ustream.tv/recorded/33615831>))
  * ((<Vimeo|URL:https://vimeo.com/TODO>))

== 発表内容

この発表ではよいソフトウェアを開発する方法を1つを紹介しました。この方法は私の経験をベースとしています。

私がソフトウェアを書き始めてから10数年経ちました。書き始めた頃から、書いたコードのほとんどをフリーソフトウェアとして公開しているので、たまに昔のコードを読む機会があります。そのとき、数年前よりも今の方がよいコードを書けるようになっていることに気づきます。この発表は、どうして自分は昔よりもよいコードを書けるようになっているのかを振り返ってみて得られた知見をまとめたものです。この知見が他のよいコードを書きたいと思っている人の参考になればよいと思って発表しました。

この発表で伝えたよいソフトウェアを開発する方法は「ライブラリー開発者になること」です。どうしてこの方法につながるのか。キーとなる考えは「想像するよりも思い出す」です。

[Be a library developer!](slide-title.png) http://slide.rabbit-shocker.org/authors/kou/rubykaigi-2013/ へのリンクにしたい

=== よいソフトウェアとはどんなソフトウェアか

「よいソフトウェアを書けるようになる方法」について考える前に、まずは「よいソフトウェア」について考えてみましょう。

こんなAPIについて考えてみましょう。これは((<cairo gem|URL:https://rubygems.org/gems/cairo>))というグラフィックスライブラリーのAPIです。

  context.save
  context.circle(50, 50, 10)
  context.stroke
  context.restore

このコードは、(({save}))で現在の描画情報を保存し、(({restore}))で保存した状態まで戻しています。(({save}))と(({restore}))の間で(({circle}))と(({stroke}))を使って円を書いています。円を書くために変更された描画情報は(({restore}))のところでは元に戻ります((-実は、この例の場合は(({save}))したときと(({restore}))直前では描画情報は変わっていないので、(({save}))と(({restore}))は必要ありません。-))。

では、このコードよりもよいコードで書けるようにするためにAPIを改良できないか考えてみましょう。「よりよい」の基準はいくつもあります。まずは、自分の「よりよい」の基準で考えてみてください。

考えましたか？

例えば、(({save}))と(({restore}))に注目してみるとどうでしょうか。

  context.save      # ← 注目
  context.circle(50, 50, 10)
  context.stroke
  context.restore   # ← 注目

ここに注目するとブロックを使った書き方を思いつきます。こちらの方がよりよいAPIです。

  context.save do
    context.circle(50, 50, 10)
    context.stroke
  end

では、どうしてブロックを使ったほうがよりよいAPIなのでしょうか。それは、よりRubyらしい書き方だからです。

「Rubyらしい」とはどういうことでしょうか。「○○らしい」とは「他と似ている」ということです。「Rubyらしい」書き方だとまわりのコードと似たような記述になります。つまり、まわりのコードと統一感が出るということです。統一感がでると読みやすくなります。読みやすくなるとメンテナンスが楽になります。いきなりよいソフトウェアを作ることは難しいため、繰り返し繰り返し継続してソフトウェアを開発していく方法が現実的です。メンテナンスが楽になると開発を継続しやすくなり、よりよいソフトウェアにつながります。

よって、「Rubyらしい書き方」にするとよりよいソフトウェアにつながるため、よりよい基準のひとつになります。

では、このブロックの使い方は「Rubyらしい」のでしょうか。Fileクラスを思い出してください。

  file = File.open(path) # 前処理
  file.read
  file.close             # 後処理

まず(({open}))でファイルを開きます。これは前処理です。(({read}))して使い終わったら閉じます。これは後処理です。

ところで、これを見て(({File.open}))ではなく(({Kernel.#open}))を使ったほうがよいと思う人もいることでしょう。理由は「記述が短い」や「ファイル以外にも対応できる」あたりでしょうか。しかし、私は(({File.open}))を使ったほうがよいと考えています。理由は「ファイルを開くことが明確なコードになるから」です。ファイルしか扱わない場所ではファイルしか扱わないAPIを使うことでコードで表現したい意図が明確になります。一方、ファイル以外にもいろいな入力を受け付けたい場合は(({Kernel.#open}))を使います。

この考えは(({end_with?}))と(({/\z/}))の使い分けにも応用が効きます。

  def ruby_script?(path)
    path.end_with?(".rb")
  end

  def ruby_script?(path)
    /\.rb\z/ =~ path
  end

(({end_with?}))を使っているコードは「パスが.rbで終わっているならRubyスクリプト」と読めます。(({/\z/}))を使っているコードは「パスが.rbで終わるパターンにマッチするならRubyスクリプト」と読めます。(({end_with?}))の方がやりたいことそのものに読めます。

少し長い余談でしたが、より多くのことができる機能よりもやりたいことそのものの機能があるならそのものの機能を使ったほうがやりたいことの意図を明確に伝えられるコードになるという例でした。

話を戻します。こんなコードを考えていたのでした。

  file = File.open(path) # 前処理
  file.read
  file.close             # 後処理

このように明示的に(({close}))を書くのはRuby初心者です。Rubyに慣れた人はこのようにブロックを使って書きます。

  File.open(path) do |file| # 前処理
    file.read
  end                       # 後処理

こうすることの利点は2つです。1つは(({close}))のし忘れがなくなるということです。もう1つは後処理の詳細を意識しなくてもよくなるということです。ファイルの場合の後処理は(({close}))で、(({Dir.chdir}))のときは元のディレクトリーに戻る、などと使いわける必要はありません。ブロックを抜けたら「いい感じ」に後処理をしてくれます。これがRubyの組み込みライブラリーで使われている後処理のためにブロックを使う方法です。つまり、これと「似た」使い方をすれば「Rubyらしい」ということです。

では、もう一度cairo gemの例を見てみましょう。

  context.save do # 前処理
    context.circle(50, 50, 10)
    context.stroke
  end             # 後処理

(({save}))が前処理の部分、ブロックを抜けたところで実行する(({restore}))は後処理の部分です。(({File}))と「似た」使い方ですね。ということでこのAPIは「Rubyらしい」といえます。

おさらいします。

「よいソフトウェアを開発する方法」について考える前に、まずは「よいソフトウェア」について考えてみました。「よい」の基準の1つは「Rubyらしい」です。「よい」を言いかえると「他と似ている」です。つまり、「よいソフトウェアを開発する方法」は「似ているとはどういうことかを知って、それと同じようにすること」と言いかえることができます。

それでは、「似ているとはどういうことかを知って、それと同じようにすること」を実現するにはどうしたらよいか考えてみましょう。

=== キーとなる考え

まず、「似ているとはどういうことかを知って、それと同じようにすること」を実現するためのキーとなる考えを説明します。

キーとなる考えは、「想像するよりも思い出す」です。

[キーとなる考え「想像するよりも思い出す」](remember-than-imagine.png)

「想像すること」は難しいことです。これは、まだ知らないことを思いつかなければいけないからです。

では、「思い出すこと」はどうでしょうか。これは、想像することに比べれば簡単なことです。なぜなら、すでに知っていることの中から適切なことを選んでくるだけだからです。新しく思いつく必要はありません。また、知っていることから選ぶ場合は、それを選んだ「結果」もわかる場合があります。「よい結果」とわかっていることを選んだ場合は、今回もうまくいく可能性がとても高いです。

では、思い出せるようになるには知っている必要があります。では、どうやって知ればよいでしょう。

[思い出せるようになるには知ること。では、どうやって知ればよいか。](how-to-get-knowledge.png)

知るためには自分で経験する方法、人から聞く方法、観察して学ぶ方法などがあります。この中でも一番初めにやることは経験してみることです。経験すれば知っているので思い出せるようになります。

ということで、キーとなる考えは「想像するよりも思い出す」です。

=== キーとなる考えを適用する

それでは、「よいソフトウェアを開発する」ために「想像するよりも思い出す」というキーとなる考えを適用してみましょう。

[キーとなる考えを適用する](apply-the-key-idea.png)

「よいソフトウェアを開発する」には、「似ているとはどういうことかを知って、それと同じようにする」とよいのでした。それでは、「似ているとはどういうことかを知る」ために何を経験すればいいでしょうか。

[知るためには何を経験すればよいか](what-experience-is-needed-for-knowledge.png)

それは「Rubyist」としての経験です。

[知るためにはRubyistとしての経験が必要](rubyist-experience-is-needed-for-knowledge.png)

それでは、実際にRubyistとしての経験を活かしてみましょう。以下のコードを考えてみます。

  window.get_property("opacity")
  # よりよいAPIは？？？

これは((<gtk2 gem|URL:https://rubygems.org/gems/gtk2/>))というGUIライブラリーのAPIです。(({window}))オブジェクトの(({opacity}))プロパティの値を取得しています。では、これをどうすればよりよいAPIになるか考えてみてください。今の話の中では「よりよい」の基準として「Rubyらしい」かどうかを基準としていました。どうすればよりRubyらしいAPIになるでしょうか。

考えましたか？

以下のように「プロパティ名と同じ名前のプロパティの値を取得するメソッド」の方がRubyらしいAPI、つまりよりよいAPIです。

  window.get_property("opacity")
  window.opacity # よりよいAPI

オブジェクトのプロパティを取得するためにプロパティ名のメソッドを使うというのはRubyではよくやる方法なのでこの方法はRubyらしいです。プロパティを属性といいかえるとわかりやすいでしょう。Rubyには(({attr_reader}))という「属性名と同じ名前の属性の値を取得するメソッド」を定義するそのためのショートカットが用意されています。

発表時には触れなかったことについて補足します((-発表後に咳さんにこのことについてコメントをもらいました。-))。

gtk2 gemは((<GTK+|URL:http://www.gtk.org/>))というGUIライブラリーをRubyから使えるようにしたライブラリーです。そのため、プロパティ名はGTK+の規則に従います。プロパティ名としてRubyのメソッド名で使えない文字が使われていないか気になりましたか？実はプロパティ名には「-」も使うことができます((-参考: ((<g_param_spec_internal()のドキュメント|URL:https://developer.gnome.org/gobject/stable/gobject-GParamSpec.html#g-param-spec-internal>))-))。これだけがRubyのメソッド名では使えない文字です。ただし、プロパティ名として「-」の代わりに「_」を使ってもGTK+内部((-もう少し厳密に言うと、GTK+が使っているオブジェクトシステムであるGObjectの内部-))で「-」に正規化するため、gtk2 gemで「default-gem」プロパティ用のメソッド名として「default_height」を使っても、RubyとしてもGTK+としても問題も違和感もありません。

なお、仮にどうしても使えない文字があった場合はそのプロパティ用のメソッドは用意せず、用意できるものだけ用意するでしょう。メソッドを用意できないプロパティはそもそもRubyらしくないのでRubyの属性と似せることはできません。では、(({window["default-height"]}))((-ここではRubyのメソッド名に使えない文字を含むプロパティ名を考えているので、シンボルでプロパティ名を指定するようにはしません。(({window[:"default-height"]}))という多くの場合は使わない記法を使わなければいけなくなり、Rubyらしさから外れてしまうからです。-))のように取得できるようにするのはどうでしょうか。これについてはもう少し後で触れます。そこでは(({[]}))を使うときはどんなときかを考えます。なお、Rubyの属性と似ていないプロパティの値は(({get_property}))を使えば取得できるので、Rubyらしさから外れたものはそれらを使うという割り切りはアリです。ただし、これは多くのプロパティがRubyの属性と似ている場合です。多くのプロパティが似ていない場合は無理やりRubyの属性と似せようとしてはいけません。思い出すものを間違っています。

補足はここまでです。

ところで、今、よりよいAPIを考えられましたか？「思い出す」というのは意外と「難しい」と思いませんでしたか？((-ここは難しいと思って欲しいところです。-))そう、難しいんです。「思い出せ！？」「Rubyらしいって何！？」そう思ったことでしょう。

[思い出すことは難しい](remember-is-difficult.png)

すでに知っているはずなのにどうして思い出すことが難しいのでしょう。それは、「想像するよりも思い出す」という経験をしていないからです。今、みなさんは経験したのではなく、「読んだだけ」という状態です。

[思い出す経験をしていない](no-remember-experience.png)

それでは、もう一度。「よいソフトウェアを開発する」、「似ているとはどういうことかを知って、それと同じようにする」を実現するためには何を経験したらよいのでしょうか。それは、ライブラリー開発者としての経験です。ここでようやくこの話のタイトルがでてきました。

[ライブラリー開発者としての経験が有効](library-developer-experience-is-useful.png)

ライブラリー開発者はRubyistとして使いやすいAPIとはどういうAPIだろうと考えたり、ライブラリーのユーザーとしてわかりやすいドキュメントはどんなドキュメントだろう、ということを考えます。他にもいろいろ考えます。そして、これらを何度も何度もたくさん考えます。考える機会がたくさんあるのです。「たくさん」というのはとてもよい練習になります。そのため、「想像するよりも思い出す」をうまくやるためにはライブラリー開発者になることをオススメします。

それではいくつか練習してみましょう。

まずは簡単な練習です。プロパティの値を取得するには以下のようにプロパティ名と同じ名前のメソッドを用意するのがRubyらしいのでした。

  # 低レベルなAPI
  window.get_property("opacity")
  # よりよいAPI
  window.opacity

それでは、(({visible}))というプロパティという場合はどうでしょう。ヒントは(({visible}))は真偽値を返すということです。

  # 低レベルなAPI
  window.get_property("visible")
  # よりよいAPIは？
  # ???: ヒント: "visible"は真偽値を返す

考えましたか？

Rubyらしくするならメソッド名の最後に「?」をつけますね。

  # 低レベルなAPI
  window.get_property("visible")
  # よりよいAPI
  window.visible?

では、なんでもメソッド名にすればよいのでしょうか。この例ではどうでしょう。

  # レコードを「コレクション」と考えるならよりよいAPI
  record["name"]
  # レコードを「オブジェクト」と考えるならよりよいAPI
  record.name

ここの(({record}))はテーブルの中の1つのレコードです。このレコードのカラムの値にアクセスするにはHashのようにアクセスするのとメソッドでアクセスするのはどっちがよいでしょうか。レコードをカラムが集まったコレクションと考えるならHashのようにアクセスするのがRubyらしいですし、オブジェクトと考えるならメソッドでアクセスするのがRubyらしいです。

さて、それではGUIのウィジェットであるウィンドウはプロパティが集まったコレクションと考えられるでしょうか。ウィンドウの主要な機能はプロパティの操作ではなくGUI関連の機能です。そのため、コレクションと考えるよりもオブジェクトと考える方が妥当です。よって、プロパティにアクセスするために(({[]}))を使うのはRubyらしくありません((-Structクラスは(({[]}))でメンバーにアクセスできるので、ものすごくRubyらしくないというほどではありません。-))。

少し難しい例も考えてみましょう。この例は発表時には省略した例です。

この例の(({Gst.init}))をよりよくできないでしょうか。

  require "gst"
  Gst.init # ← よりよくしたい
  Gst::ElementFactory.make("playbin")

通常のライブラリーは(({require}))すれば使えますが、このAPIでは(({require}))しただけでは使えません。(({require}))した後に(({Gst.init}))を呼ぶ必要があります。

そもそも(({Gst.init}))はなんのために必要なのかというと、デバッグオプションを指定するなど高度な使い方をしたいときに必要になります。

  require "gst"
  Gst.init("--gst-debug=*:9") # ← 高度な使い方のために必要
  Gst::ElementFactory.make("playbin")

変わった使い方をするために通常の使い方と変わってしまうのはしょうがありませんが、それが通常の使い方をしたいときにも影響を与えてしまっては使い勝手が悪いです。どうしたらよりよいAPIになるでしょうか。

考えましたか？

高度な使い方をしなくてもよいときは(({Gst.init}))を呼ばなくても動くようにします。

  require "gst"
  # Gst.init # ← オプションにして呼ばなくても動くようにする
  Gst::ElementFactory.make("playbin")

Rubyでは(({require}))したらすぐにライブラリーを使えるようになるので、(({require}))だけで使えるようにする、ということです。他のライブラリーの使い方に似せたということです。

参考までに実装方法を紹介します。ポイントは(({const_missing}))と(({remove_method}))です。

  class << Gst
    def const_missing(name)
      init
      const_get(name)
    end

    def init(*argv)
      # ライブラリーを初期化
      class << self
        remove_method(:const_missing)
      end
    end
  end

必要なときだけ(({Gst.init}))を呼べばよいAPIを「思い出す」ことはできるでしょうが、どうやって実装するかは「思い出す」ことはできないでしょう。これについては、もう少し後で触れます。

次は、APIではなくドキュメントについて考えてみましょう。ソフトウェアの開発はコードを書くだけではありません。

これはgtk2 gemのインストールドキュメントを書いた例です。

  インストール方法：

    Debian GNU/Linuxでは：
      % sudo apt-get install libgtk2.0-dev
      % gem install gtk2
    OS Xでは：
      ...

gtk2 gemは拡張ライブラリーなので事前にGTK+というCのライブラリーをインストールしておく必要があります。ユーザーのことを考えるとドキュメントにはその旨を書いておかないと、となります。でも、これでよいのでしょうか。よりよいドキュメントならこうするべきです。

  インストール方法：
    % gem install gtk2

gemをインストールするときは「(({gem install gem名}))」が普通のやり方です。これがRubyGemsらしさです。普通はこれでインストールするなら、これでインストールできるようにするべきなのです。gtk2 gemは(({gem install gtk2}))とやったら必要なパッケージを自動でインストールするようにして、インストールドキュメントは(({gem install gtk2}))だけにしています。

発表時には触れなかったことについて2つ補足します。1つはパッケージを自動でインストールするということについてです。もう1つはパッケージを自動でインストールするということをどうやって思いつくかということについてです。

まずは、パッケージを自動でインストールするということについてです。

gem以外のパッケージを勝手にインストールされるのがイヤだと思った人がいるはずです。私も昔はそう思っていましたが、以下の理由から自動でインストールしたほうがよいと思うようになりました。

  * インストールでつまづいている人をたくさん見た
  * セキュリティー的な脅威は変わらない
  * どうせ手動で同じことをやることになる

最初の「インストールでつまづいている人をたくさん見た」ことが一番大きな理由です。gemをインストールしたい人が一番したいことは「使うこと」です。インストールが大変なため、使う前に諦めたり、インストールしたことに満足して使うことがどうでもよくなったりした人を見てきました。いくらよりよいAPIのライブラリーでも使われなければAPIのよさは関係ありません。そのため、インストールでつまづかないようにすることを重視するようになりました。

セキュリティーについても考えました。自動でインストールすることでセキュリティ的な脅威は増えるのか。

Linux環境では(({sudo}))経由でインストールコマンドを実行します。セキュリティーを重視している人は(({sudo}))を実行する前にパスワードを入力する設定にしているはずです。(({sudo}))のパスワード入力を促すプロンプトには「○○というパッケージをインストールするために(({sudo}))のパスワードを入力してください」とでるようにしています。そのため、セキュリティーを意識している人たちは適切に判断するタイミングと判断する材料を提供しているため深刻な問題はないと考えています。もし、パスワードなしで(({sudo}))を実行できるようにしている場合はそれほどセキュリティーを意識していないと考えられるため、それほどケアしなくても問題ないと考えています。

OS X環境でHomebrewを使っている場合は(({sudo}))を使わないでそのまま実行します。つまり、パッケージのインストールを確認するプロセスがありません。では、パッケージのインストールを確認するプロセスが必要なのかを考えてみましょう。(({gem install ...}))としているのでパッケージをインストールしたいという意思を示したと考えることができます。つまり、すでにインストールしたいと示したのでよきに計らうことの方がユーザーの意思を反映しているという考えです。強引でしょうか。多少強引かもしれません。

では、そもそも、一般ユーザー権限で(({gem install ...}))することはそんなに安全なのでしょうか。ホームディレクトリーを削除する悪意のあるライブラリーをインストールして使ってしまうという危険性が考えられます。サーバー上の特定サービス用のユーザーであれば被害を最小限に抑えられるため安全と言えます。では、開発用のマシンや普段使いのマシンではどうでしょうか。/usr/以下を全部削除されるより、ホームディレクトリーを削除される方が被害が大きいのではないでしょうか。システムはインストールしなおせばよいですが、ホームディレクトリーは最後にバックアップしたところまでしか復旧できません。このような前提を考えると、自動でシステムにパッケージをインストールしようとしてもセキュリティー的な脅威はそれほど変わらないと言えるでしょう。

自動でインストールしない場合についても考えました。自動でインストールしない場合は、使いたいなら手動でシステムにパッケージをインストールします。どうせ同じことをするのです。私は((<nokogiri gem|URL:http://rubygems.org/gems/nokogiri>))をインストールするときに、(({gem install nokogiri}))して失敗して、(({sudo apt-get install ...}))して、再度(({gem install nokogiri}))をしていました。

どうせ手動でパッケージをインストールするのであれば、最初から自動でインストールしても同じことです。もし、パッケージを追加でインストールすることにシビアに考えている人はインストールする前に依存しているライブラリーを調べるはずです。それらの人のためには、インストール方法のドキュメントとは別の場所に依存ライブラリーをリストアップしておくことができます((-インストール方法のドキュメントのところにリンクを張るのが親切です。-))。本当にシビアな人は調べるはずです。

長くなりましたが、パッケージを自動でインストールするようにしても、よく考えてみれば、最初に抱くイメージほど変なことではないと考えるようになったということです。

もう1つ補足します。パッケージを自動でインストールするという方法をどうやって思いつくかということについてです((-発表時に田中さんからこれに関する質問がありました。発表後に長永さんともこれに関する話をしました。-))。

パッケージを自動でインストールする方法は他のライブラリーではやっていません。そのため、知っていることを「思い出す」ということはできません。目指したい場所は思い出すことはできるがそこまでの道のりは思い出すことはできない、ということはよくあります。少し前の(({Gst.init}))を呼ばなくてもしたいという例もこのケースです。

TODO: 今いる場所とゴールがわかっている状態。間をどうやって埋めていくか。


ということで、実際に「想像するんじゃなくて思い出す」というキーとなる考えを適用してみました。Rubyユーザーとして普通はどうやっているかを「思い出す」、そしてそれと同じようにする、という例を示しました。ピンときましたか？

== まとめ

まとめます。この話のゴールは「よりよいソフトウェアを開発するための方法をみなさんが知ること」でした。「よりよい」とは「Rubyらしい」、言い換えると「他と似ている」ということです。これを実現するためのキーとなる考えが「想像するんじゃなくて思い出す」です。なぜなら想像することは知らないので難しく、思い出すことは知っているので簡単だからです。ソフトウェア開発に当てはめてみると、思い出すためにはRubyユーザーとしての経験が必要です。あとはその経験を思い出せばいいのです。しかし、「思い出す」という経験がないので「思い出す」ことが難しいことでしょう。「思い出す」経験をするためにはライブラリー開発者になることをおすすめします。ライブラリーを開発すると何度も何度も「思い出す」必要があり、とてもよい練習になります。という話をしました。

== 次のステップ

最後にライブラリー開発者になった後の話をして終わりにします。

「ライブラリー開発者」としての経験を他のことにも使ってください。たとえば、他のソフトウェアの開発に使ってください。Rubyでもいいです。他のソフトウェアを開発するときには、よりよいバグレポートはどんなバグレポートだろうとか、よいパッチはどんなパッチだろうとかを「思い出して」ください。例えば、バグレポートなら再現方法があるとうれしいですし、期待する結果もあるとうれしいですね。パッチならわかりやすい単位で分割されているとうれしいですし、適切なコミットメッセージがついているとうれしいですね。ライブラリー開発者としてバグレポートをもらった経験を思い出せばいろいろわかるはずです。

ということで、ライブラリー開発者になりましょう！
